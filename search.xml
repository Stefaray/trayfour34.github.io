<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法9.打印从1到最大的n位数</title>
      <link href="/posts/34866.html"/>
      <url>/posts/34866.html</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-text"><code class="language-text">输入: n = 1输出: [1,2,3,4,5,6,7,8,9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法：DFS递归"><a href="#方法：DFS递归" class="headerlink" title="方法：DFS递归"></a>方法：DFS递归</h5><blockquote><p>时间复杂度：$O(10^n)$    </p><p>空间复杂度：$O(10^n)$      </p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">char</span> digital<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'0'</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">,</span><span class="token string">'5'</span><span class="token punctuation">,</span><span class="token string">'6'</span><span class="token punctuation">,</span><span class="token string">'7'</span><span class="token punctuation">,</span><span class="token string">'8'</span><span class="token punctuation">,</span><span class="token string">'9'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    <span class="token keyword">int</span> total_bits<span class="token punctuation">;</span>    <span class="token keyword">char</span> num<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">printNumbers</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        total_bits <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// num = new char[n];</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// delete[] num;</span>        res<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> total_bits<span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                num<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> digital<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>这道题乍一看很简单，题目也没有要求考虑大数条件。但如果考虑了大数条件，就会变得稍微复杂起来了。本题在考虑大数情况下，采用$DFS$递归，主要思路是先固定高位，向低位递归，当个位数被固定，再固定十位<code>0~9</code>，按顺序开启递归，直到到达最高位，终止递归。</p><p><img src="https://cdn.jsdelivr.net/gh/trayfour34/Picture_Bed/20200926104904.png" alt="image-20200926104904551"></p><p><strong>主要步骤</strong></p><ul><li>定义一个<code>n</code>位数的字符数组，用来存放最终结果。</li><li>先将所有要用到的数组或者变量放到全局中，以免递归的时候多次传递。</li><li>递归传入一个索引<code>index</code>，刚开始索引为0，待到索引为<code>n</code>的时候，结束本次递归。</li><li>对每一位按照<code>0~9</code>的顺序依次分配字符。</li></ul><p><strong>解法注意点</strong></p><ul><li>最后生成的字符串需要通过<code>atoi</code>函数变成整数。</li><li>去掉第一项（题目要求开头不为0）</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> DFS </tag>
            
            <tag> 大数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法8.数值的整数次方</title>
      <link href="/posts/45405.html"/>
      <url>/posts/45405.html</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-text"><code class="language-text">输入: 2.00000, 10输出: 1024.00000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-text"><code class="language-text">输入: 2.10000, 3输出: 9.26100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3:</strong></p><pre class="line-numbers language-text"><code class="language-text">输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法一：快速幂解析"><a href="#方法一：快速幂解析" class="headerlink" title="方法一：快速幂解析"></a>方法一：快速幂解析</h5><blockquote><p>时间复杂度：$O(log_2n)$    </p><p>空间复杂度：$O(1)$      </p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> positive_n <span class="token operator">=</span> <span class="token function">llabs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>positive_n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>positive_n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res <span class="token operator">*</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            x <span class="token operator">*</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            positive_n <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span>res<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// cout&lt;&lt;res&lt;&lt;endl;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>由于题目说明不需要考虑大数运算，本题的关键就转到了时间复杂度上。用了常规方法试了多次$TLE$后，才知道普通的无脑<code>for​</code>循环是不可取的。联系到上一题求二进制1的个数，可以联想采用快速幂的方法来简化计算量。</p><p>将十进制数字 <code>n</code> 的二进制表示，可对快速幂进行数学化解释</p><p><img src="https://cdn.jsdelivr.net/gh/trayfour34/Picture_Bed/20200925162347.png" alt="快速幂解析图"></p><p><strong>主要步骤</strong></p><ul><li>循环32次，每次循环都执行$x=x^2$。将中间结果成倍增加，相比$for$减少了大量计算。</li><li>每次循环中执行<code>n&amp;1</code>，如果为真则将结果<code>res</code>和<code>x</code>相乘，保存到<code>res</code>中。</li><li>每次循环结尾将<code>n</code>右移1位。</li></ul><h5 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h5><blockquote><p>时间复杂度：$O(log_2n)$</p><p>空间复杂度：$O(log_2n)$</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果n小于0，把它改为正数，并且把1/x提取出来一个</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">/</span> x <span class="token operator">*</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> x<span class="token punctuation">,</span> <span class="token operator">-</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">,</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">:</span> x <span class="token operator">*</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">,</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>总体思路和上述方法类似，只是换了种方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
            <tag> 位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法7.剪绳子</title>
      <link href="/posts/53322.html"/>
      <url>/posts/53322.html</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，<code>n&gt;1</code>并且<code>m&gt;1</code>），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-text"><code class="language-text">输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-text"><code class="language-text">输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法一：动态规划-自底向上"><a href="#方法一：动态规划-自底向上" class="headerlink" title="方法一：动态规划(自底向上)"></a>方法一：动态规划(自底向上)</h5><blockquote><p>时间复杂度：$O(N^2)$    </p><p>空间复杂度：$O(N)$     </p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">cuttingRope</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// cout&lt;&lt;dp[n]&lt;&lt;endl;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>绳子有着固定长度<code>n</code>，动态规划的思想就是把<code>1~n-1</code>的所有值都求出来放在一个数组里，通过前面这些值来求n的值。本题的思路也是这样的：</p><p>假设<code>dp[n]</code>代表绳子长度为n切出来乘积结果的最大值。那么求<code>dp[n]</code>的时候，每次都从<code>1~n-1</code>遍历一遍，将<code>dp[n]</code>分解成<code>dp[i]</code>和<code>dp[n-i]</code>的乘积，再比较遍历中的最大值。</p><p><strong>解法注意点</strong></p><p>因为本题要求绳子至少要切一次，所以无论绳子有多短（比如<code>n=2</code>），也要想办法切出来，即使最终的乘积比没切的时候还小。因此就会出现下列特殊情况：</p><ul><li><code>n=2    dp[n]=1&lt;2</code></li><li><p><code>n=3    dp[n]=2&lt;3</code></p></li><li><p><code>n=4    dp[n]=4=4</code></p></li></ul><p>举个例子，当<code>n=8</code>时，切成<code>i=3</code>和<code>n-i=5</code>时，<code>dp[3]</code>就不再是最优解了，因此这个时候应该停止切分<code>dp[3]</code>，所以在算法判别的时候，要加入<code>max(dp[j],j)</code>这个元素。</p><h5 id="方法二：记忆化递归-自顶向下"><a href="#方法二：记忆化递归-自顶向下" class="headerlink" title="方法二：记忆化递归(自顶向下)"></a>方法二：记忆化递归(自顶向下)</h5><blockquote><p>时间复杂度：$O(2^N)$    </p><p>空间复杂度：$O(N)$     若不用空间数组，则空间复杂度为$O(2^N)$</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">cuttingRope</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 使用辅助函数</span>        <span class="token keyword">def</span> <span class="token function">memoize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">1</span>            <span class="token keyword">if</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果f[n]已经计算过，直接返回避免重复计算</span>                <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span>            res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> max<span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span>i <span class="token operator">*</span> memoize<span class="token punctuation">(</span>n <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> res            <span class="token keyword">return</span> res        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> memoize<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>绳子有着固定长度<code>n</code>，动态规划的思想就是把<code>1~n-1</code>的所有值都求出来放在一个数组里，通过前面这些值来求n的值。本题的思路也是这样的：</p><p>假设<code>dp[n]</code>代表绳子长度为n切出来乘积结果的最大值。那么求<code>dp[n]</code>的时候，每次都从<code>1~n-1</code>遍历一遍，将<code>dp[n]</code>分解成<code>dp[i]</code>和<code>dp[n-i]</code>的乘积，再比较遍历中的最大值。</p><p><img src="https://cdn.jsdelivr.net/gh/trayfour34/Picture_Bed/20200926102625.png" alt="递归图示"></p><p><strong>解法注意点</strong></p><p>相比于不开数组直接递归，这种解法对空间和时间更友好一些。暴力解法会超时，但是很多进阶解法往往是暴力解法的优化。注意到上述代码中超时的原因主要是因为重复计算了 $F(n)$，为了避免重复计算可以使用 记忆化技术。</p><p>记忆化技术的代码中经常需要建立函数 <code>memoize</code> 辅助实现。我们使用数组 <code>f</code> 来保存长度为 <code>i</code>时的最大长度 <code>f[i]</code>，最后返回 <code>f[n]</code>即可。</p><h5 id="方法三：数学推导"><a href="#方法三：数学推导" class="headerlink" title="方法三：数学推导"></a>方法三：数学推导</h5><blockquote><p>时间复杂度：$O(1)$    </p><p>空间复杂度：$O(1)$     </p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">cuttingRope</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">2</span><span class="token operator">||</span>n<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> n<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">4</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">4</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                sum <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>                sum <span class="token operator">%</span><span class="token operator">=</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>                n <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            sum <span class="token operator">*</span><span class="token operator">=</span> n<span class="token punctuation">;</span>            sum <span class="token operator">%</span><span class="token operator">=</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>利用数学推导算出最优解，极大简化计算量。</p><p>此题运用了均值不等式，得出切得绳子长度尽可能一样，最后的结果越大；再利用求导取极大值，来算出具体是切到哪个长度结果会最大。数学推导过程参照力扣大神<a href="https://leetcode-cn.com/u/jyd/" target="_blank" rel="noopener">Krahets</a>的题解。</p><p><img src="https://cdn.jsdelivr.net/gh/trayfour34/Picture_Bed/20200926103702.jpg" alt="数学推导过程"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 数学推导 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法6.矩阵中的路径找寻</title>
      <link href="/posts/54780.html"/>
      <url>/posts/54780.html</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的<code>3×4</code>的矩阵中包含一条字符串<code>bfce</code>的路径（路径中的字母用加粗标出）。</p><p><code>[["a","b","c","e"],</code><br><code>["s","f","c","s"],</code><br><code>["a","d","e","e"]]</code></p><p>但矩阵中不包含字符串<code>abfb</code>的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：board = [["a","b"],["c","d"]], word = "abcd"输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法：DFS-剪枝"><a href="#方法：DFS-剪枝" class="headerlink" title="方法：DFS+剪枝"></a>方法：DFS+剪枝</h5><blockquote><p>时间复杂度：$O(3^KMN)$    最差情况下，需要遍历矩阵中长度为 $K$ 字符串的所有方案，时间复杂度为 $O(3^K)$；矩阵中共有 $MN$个起点，时间复杂度为 $O(MN)$。</p><p>空间复杂度：$O(K)$     搜索过程中的递归深度不超过 $K$ ，因此系统因函数调用累计使用的栈空间占用 $O(K)$</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">exist</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> string word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> word<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>board<span class="token punctuation">,</span>word<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> string word<span class="token punctuation">,</span><span class="token keyword">int</span> word_index<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>i<span class="token operator">>=</span>board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>j<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>j<span class="token operator">>=</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span>word<span class="token punctuation">[</span>word_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> word_index<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">char</span> tmp <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> judge <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>board<span class="token punctuation">,</span>word<span class="token punctuation">,</span>word_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>board<span class="token punctuation">,</span>word<span class="token punctuation">,</span>word_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                        <span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>board<span class="token punctuation">,</span>word<span class="token punctuation">,</span>word_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token number">-1</span><span class="token punctuation">,</span>board<span class="token punctuation">,</span>word<span class="token punctuation">,</span>word_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token keyword">return</span> judge<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><ul><li><strong>深度优先搜索</strong>： 可以理解为暴力法遍历矩阵中所有字符串可能性。<code>DFS</code> 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li><li><strong>剪枝</strong>： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</li></ul><p><strong>算法剖析</strong></p><ul><li><strong>终止条件</strong><ul><li>行列越界</li><li>矩阵元素和目标元素不同</li><li>当前元素已经访问过</li></ul></li><li><strong>递推过程</strong><ul><li>遍历一遍二维数组，找到第一个匹配的元素</li><li>将当前元素暂存于<code>tmp</code>变量中，修改当前变量为<code>/</code>。这么做代表这个元素已经访问过，后面无需再重新访问</li><li>对当前元素上下左右进行递归</li><li>将当前变量还原</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法5.旋转数组的最小数字</title>
      <link href="/posts/14530.html"/>
      <url>/posts/14530.html</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p><p><strong>示例 1：</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,4,5,1,2]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2,2,2,0,1]输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法：二分法"><a href="#方法：二分法" class="headerlink" title="方法：二分法"></a>方法：二分法</h5><blockquote><p>时间复杂度：$O(log_2n)$    若数组中所有元素都相同，则退化到$O(N)$</p><p>空间复杂度：$O(1)$    </p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> numbers<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>                start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> numbers<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>                end <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span>                 end<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout<span class="token operator">&lt;&lt;</span>numbers<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> numbers<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p><img src="https://cdn.jsdelivr.net/gh/trayfour34/Picture_Bed/20200925233420.png" alt="旋转后图示"></p><p>如上图所示，由于旋转，数组呈两次递增状态，最低点夹在中间。通过二分法可以判定出最低点的位置。具体判定如下：</p><blockquote><p>设<code>start=0</code>，<code>end=size()-1</code></p></blockquote><ul><li>当<code>mid</code>所处的值大于<code>start</code>所处的值时，证明最低点在右边，因此二分法取后者</li><li>当<code>mid</code>所处的值小于<code>start</code>所处的值时，证明最低点在左边，因此二分法取前者</li><li>当数组所有元素都是同一个值时，上述方法不再试用，二分法相当于遍历了一遍数组。</li></ul><p><strong>解法注意点</strong></p><p>主要在于当<code>mid</code>所处的值等于<code>start</code>所处的值时，要怎么去处理二分法。上述代码是将<code>end</code>往前移动了一位。其形式相当于遍历。从代码量来说，不失为一种好方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法4.前序中序重建二叉树</title>
      <link href="/posts/40218.html"/>
      <url>/posts/40218.html</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-text"><code class="language-text">给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：    3   / \  9  20    /  \   15   7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法一：使用栈解决"><a href="#方法一：使用栈解决" class="headerlink" title="方法一：使用栈解决"></a>方法一：使用栈解决</h5><blockquote><p>时间复杂度：$O(N)$    前序遍历和后序遍历都被遍历。</p><p>空间复杂度：$O(N)$      额外使用栈存储已经遍历过的节点。</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> map_inorder<span class="token punctuation">;</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 前序：[3,9,20,15,7]</span>        <span class="token comment" spellcheck="true">// 中序：[9,3,15,20,7]</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            map_inorder<span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> part_root <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> <span class="token function">recure</span><span class="token punctuation">(</span>part_root<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>preorder<span class="token punctuation">,</span>inorder<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// cout&lt;&lt;root->val&lt;&lt;endl;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">recure</span><span class="token punctuation">(</span><span class="token keyword">int</span> part_root<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> map_inorder<span class="token punctuation">[</span>preorder<span class="token punctuation">[</span>part_root<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// cout&lt;&lt;mid&lt;&lt;endl;</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">=</span> preorder<span class="token punctuation">[</span>part_root<span class="token punctuation">]</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">recure</span><span class="token punctuation">(</span>part_root<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token number">-1</span><span class="token punctuation">,</span>preorder<span class="token punctuation">,</span>inorder<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">recure</span><span class="token punctuation">(</span>part_root<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>mid<span class="token operator">-</span>left<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>preorder<span class="token punctuation">,</span>inorder<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>如果使用栈来解决首先要搞懂一个知识点，就是前序遍历挨着的两个值比如<code>m</code>和<code>n</code>，他们会有下面两种情况之一的关系。</p><ol><li><code>n</code>是<code>m</code>左子树节点的值。</li><li><code>n</code>是<code>m</code>右子树节点的值或者是m某个祖先节点的右节点的值。</li></ol><p><strong>解法注意点</strong></p><ul><li>根据中序队列首元素，遍历前序队列，不相等则入栈，并一直找到左子树。</li><li>若相等，则开始出栈，前进中序队列<code>index</code>，相等则不断出栈。</li><li>当有不相等，则说明该节点是父节点，将前序队列下一个节点放到这个节点的右子树上</li></ul><h5 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h5><blockquote><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(N)$</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> map_inorder<span class="token punctuation">;</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 前序：[3,9,20,15,7]</span>        <span class="token comment" spellcheck="true">// 中序：[9,3,15,20,7]</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            map_inorder<span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> part_root <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> <span class="token function">recure</span><span class="token punctuation">(</span>part_root<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>preorder<span class="token punctuation">,</span>inorder<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// cout&lt;&lt;root->val&lt;&lt;endl;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">recure</span><span class="token punctuation">(</span><span class="token keyword">int</span> part_root<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> map_inorder<span class="token punctuation">[</span>preorder<span class="token punctuation">[</span>part_root<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// cout&lt;&lt;mid&lt;&lt;endl;</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">=</span> preorder<span class="token punctuation">[</span>part_root<span class="token punctuation">]</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">recure</span><span class="token punctuation">(</span>part_root<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token number">-1</span><span class="token punctuation">,</span>preorder<span class="token punctuation">,</span>inorder<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">recure</span><span class="token punctuation">(</span>part_root<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>mid<span class="token operator">-</span>left<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>preorder<span class="token punctuation">,</span>inorder<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><ul><li>递推参数： 前序遍历中根节点的索引<code>pre_root</code>、中序遍历左边界<code>in_left</code>、中序遍历右边界<code>in_right</code>。</li><li>终止条件： 当 <code>in_left &gt; in_right</code> ，子树中序遍历为空，说明已经越过叶子节点，此时返回 $null$。</li><li>递推工作：<ul><li>建立根节点<code>root</code>： 值为前序遍历中索引为<code>pre_root</code>的节点值。</li><li>搜索根节点<code>root</code>在中序遍历的索引i： 为了提升搜索效率，本题解使用哈希表 <code>dic</code> 预存储中序遍历的值与索引的映射关系，每次搜索的时间复杂度为 $O(1)$。</li><li>构建根节点root的左子树和右子树： 通过调用 <code>recur()</code> 方法开启下一层递归。<br>  左子树： 根节点索引为 <code>pre_root + 1</code> ，中序遍历的左右边界分别为 <code>in_left</code> 和 <code>i - 1</code>。<br>  右子树： 根节点索引为 <code>i - in_left + pre_root + 1</code>（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为 <code>i + 1</code> 和 <code>in_right</code>。</li></ul></li><li>返回值： 返回 <code>root</code>，含义是当前递归层级建立的根节点 <code>root</code> 为上一递归层级的根节点的左或右子节点。</li></ul><p><strong>解法注意点</strong></p><ul><li>根据题目描述输入的前序遍历和中序遍历的结果中都不含重复的数字，其表明树中每个节点值都是唯一的。</li></ul><blockquote><p><strong>前序遍历特点</strong>： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序，<br><strong>中序遍历特点</strong>： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序，<br><strong>后序遍历特点</strong>： 节点按照 [ 左子树 | 右子树 | 根节点 ] 排序，</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 堆栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法3.链表反转</title>
      <link href="/posts/27192.html"/>
      <url>/posts/27192.html</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：head = [1,3,2]输出：[2,3,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法一：链表拼接"><a href="#方法一：链表拼接" class="headerlink" title="方法一：链表拼接"></a>方法一：链表拼接</h5><blockquote><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(1)$</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>            ListNode<span class="token operator">*</span> reverse_res <span class="token operator">=</span><span class="token function">reverse</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>reverse_res<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>reverse_res<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                reverse_res <span class="token operator">=</span> reverse_res<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// cout &lt;&lt; res &lt;&lt; endl;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    ListNode<span class="token operator">*</span> <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            ListNode<span class="token operator">*</span> tmp<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>            ListNode<span class="token operator">*</span> cur<span class="token operator">=</span>head<span class="token punctuation">;</span>            ListNode<span class="token operator">*</span> prev<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span>                tmp <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>prev<span class="token punctuation">;</span>                prev<span class="token operator">=</span>cur<span class="token punctuation">;</span>                cur<span class="token operator">=</span>tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>每次移动一个节点到新的指针中。</p><p>具体方法是：创建三个指针，一个是临时指针<code>tmp</code>，用来转移节点；一个指向原数组<code>cur</code>，用来在每次<code>while</code>循环定位接下来该转移的节点；一个是<code>prev</code>，存放反转后的链表。</p><p><strong>解法注意点</strong></p><ul><li>注意理解三个指针交换过程的逻辑。</li></ul><h5 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h5><blockquote><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(N)$</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token function">reversePrint</span><span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>每次传入 <code>head-&gt;next</code> ，以 <code>head == null</code>（即走过链表尾部节点）为递归终止条件，此时直接返回。回溯时用队列接着节点。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法2.二维数组中的查找</title>
      <link href="/posts/58914.html"/>
      <url>/posts/58914.html</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-text"><code class="language-text">现有矩阵 matrix 如下：[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法一：二叉搜索树"><a href="#方法一：二叉搜索树" class="headerlink" title="方法一：二叉搜索树"></a>方法一：二叉搜索树</h5><blockquote><p>时间复杂度：$O(M+N)$</p><p>空间复杂度：$O(1)$</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> i<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 <code>target</code> 大的元素就向左，反之向右，即可找到目标值 <code>target</code> 。</p><p><img src="https://raw.githubusercontent.com/trayfour34/Picture_Bed/master/20200920143519.png" alt="image-20200920143519269"></p><h5 id="方法二：线性查找"><a href="#方法二：线性查找" class="headerlink" title="方法二：线性查找"></a>方法二：线性查找</h5><blockquote><p>时间复杂度：$O(N+M)$</p><p>空间复杂度：$O(1)$</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> columns <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> column <span class="token operator">=</span> columns <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>row <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> column <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>column<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                column<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                row<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 <code>true</code>。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。</p><p>可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。</p><ul><li>若数组为空，返回 <code>false</code></li><li>初始化行下标为 0，列下标为二维数组的列数减 1</li><li>重复下列步骤，直到行下标或列下标超出边界<ul><li>获得当前下标位置的元素 <code>num</code></li><li>如果 <code>num</code> 和 <code>target</code> 相等，返回 <code>true</code></li><li>如果 <code>num</code> 大于 <code>target</code>，列下标减 1</li><li>如果 <code>num</code> 小于 <code>target</code>，行下标加 1</li></ul></li><li>循环体执行完毕仍未找到元素等于 <code>target</code> ，说明不存在这样的元素，返回 <code>false</code></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法1.数组中重复的数字</title>
      <link href="/posts/32976.html"/>
      <url>/posts/32976.html</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为 <code>n</code> 的数组 <code>nums</code> 里的所有数字都在 0～<code>n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法一：原地置换"><a href="#方法一：原地置换" class="headerlink" title="方法一：原地置换"></a>方法一：原地置换</h5><blockquote><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(1)$</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>主要思路在于将数组<code>index</code>和相应的<code>value</code>对应起来。在<code>while</code>循环体内，每个值至多通过两次（多数是一次）交换，规划到相应的位置。因此时间复杂度为$O(N)$</p><p><strong>解法注意点</strong></p><ul><li><code>while</code>循环的复杂度需要均摊分析</li><li>如果要求不改变原数组，则此方法无效</li><li>如果题目没有规定 「所有数字都在 0～<code>n-1</code> 的范围内」，则此方法无效。（考虑数组空间）</li><li>做题的时候，需要考虑时间复杂度、空间复杂度、是否可以改变原数组等。</li></ul><h5 id="方法二：Hash映射法"><a href="#方法二：Hash映射法" class="headerlink" title="方法二：Hash映射法"></a>方法二：Hash映射法</h5><blockquote><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(N)$</p></blockquote><p><strong>代码如下</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> map<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> num<span class="token punctuation">;</span>            map<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法分析</strong></p><p>通过<code>map</code>映射，将数字逐个放到<code>hash</code>表里，若某个数之前<code>hash</code>没有，则值<code>true</code>；若某个数之前<code>hash</code>存在，即映射过程中发现值为<code>true</code>，则可以判断重复。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>许久许久没有更博了...</title>
      <link href="/posts/20460.html"/>
      <url>/posts/20460.html</url>
      
        <content type="html"><![CDATA[<p>很无聊的计算了一下，距离我上一次更博的日子已经有115天了。想起了当初博客建立起来的时候，立志一天一更的画面，再看看现在……</p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="http://ray34.cn-sh2.ufileos.com/博文/许久许久没有更博了./image-20200626182638452.png" alt="我的更博速度"></h5><p>╮(╯▽╰)╭</p><p>期间也不是没有要写文章的意思，但素有拖延症本症的我总是有各种理由搪塞过去，例如但不限于最近好忙再等等、粗制滥造零容忍、惊世大篇要酝酿、无人问津无所谓……直到感觉不好意思继续拖下去的时候，才开始转过头来回顾，这些天里，我到底在干什么？</p><p>由于这场突如其来的疫情，我一直处于闲赋在家的状态，但是偶尔偶尔还是会出去见一见冠冠，看一看婆婆，亦或是跟着朋友去happy。日子一天天过去，我有时候甚至会感觉，能有一个学期感受在家学习上课的机会，其实特别特别好。以后再也很难有机会跟家人相处这么长的时间，待到踏入社会工作之际，朋友之间的见面也不会有现在那么频繁，人呐，总是要慢慢孤独下去的。因此，我十分享受这段因为疫情被迫在家的生活。</p><p>要问在这段日子里有没有让我感到特别快乐的瞬间，大抵是在二月的时候建了这个属于自己的独立网站空间吧。感觉自己的心在偌大的网络世界里有了一块安身之地，也十分满意这个博客的整体设计，直到四个月后的现在来看，也觉得自己当初的设计特别到位（自夸ing）</p><p>另外在这段期间，用上学期兼职的钱买了台iPad，高中同桌还帮忙挑了好久。虽然现在iPad在我这里依旧没有发挥生产力，每天只有吃灰的份，但还是很开心能拥有这样一段记忆。</p><p>结果并不是最重要的，最重要的是过程。 </p><p>如果要问我在这段时间里干了什么有意义的事情，其实我现在仔细想想还真没干什么。也许是疫情留给我的时间太长了，向来不怎么追剧的我先是追了国漫天行九歌（不是二次元，单纯着迷于剧本里的台词）后来跟了妈妈看了一两集《都挺好》后入坑了，花了三天刷完了整部剧。感觉我每当看一部剧的时候，心中都要默默吹爆这部剧的编剧无数次；但当片终人散的时候，偶尔回想起来，感觉其实也没好到爆吹的地步，甚至会觉得有点浪费时间？因此我一直很好奇追剧女生的脑回路是怎样的（疯狂暗示）</p><p>除了完成上述两个大工程之外，我回想了一遍，感觉大部分时间都在开发或者学习开发的路上了（虽然以后我不是很想走这条路）。4月份的时候，逸宏问我要不要一起参加大夏杯，这学期本来就没什么事情的我觉得这是个告别懒惰的大好机会，又是大佬主动邀请，就应下来了。不过在之前我从来没有做过手机端小程序或者APP的经历，所以刚开始还是不轻松的，好在在开发的过程中也能渐渐摸出自己的路来。经历了大概一个月的学习+实践之后，心理健康评估平台初见端倪：</p><p><img src="http://ray34.cn-sh2.ufileos.com/%E5%8D%9A%E6%96%87%2F%E8%AE%B8%E4%B9%85%E8%AE%B8%E4%B9%85%E6%B2%A1%E6%9C%89%E6%9B%B4%E5%8D%9A%E4%BA%86.%2Fimage-20200627234147028.png" alt="image-20200627234147028"></p><p>嗯哼？感觉应该还是可以的？（别骂辣别骂辣……）</p><p>五月份的时候跟着鹏宇哥哥一起参加了上海的三创赛和挑战杯，虽然三创赛没能拿奖，但经过了对项目整个流程的参与和开发，感觉还是开阔了自己不少的眼界。</p><p>这次的计划是做一个MoodRecordAndAnalyse的APP，主要的作用是让用户有个记录时刻情绪或者每日小结的地方，后台基于用户的情绪数据时刻关心用户的情绪走向，适时提供关心和相关消息推荐；同时还搭建了一个情绪交流广场，让所有人有个交流的平台。</p><p><img src="http://ray34.cn-sh2.ufileos.com/%E5%8D%9A%E6%96%87%2F%E8%AE%B8%E4%B9%85%E8%AE%B8%E4%B9%85%E6%B2%A1%E6%9C%89%E6%9B%B4%E5%8D%9A%E4%BA%86.%2Fimage-20200627234410342.png" alt="image-20200627234410342"></p><p><img src="http://ray34.cn-sh2.ufileos.com/%E5%8D%9A%E6%96%87%2F%E8%AE%B8%E4%B9%85%E8%AE%B8%E4%B9%85%E6%B2%A1%E6%9C%89%E6%9B%B4%E5%8D%9A%E4%BA%86.%2Fimage-20200627234419855.png" alt="image-20200627234419855"></p><p>有了之前大夏杯积累的经验，这次感觉会熟练很多。同时我想体验一下全栈式是怎样的感觉，因此这次我几乎单独进行了前端和后端的所有制作的过程。这样的后果就是前端有bug后端也有bug，每时每刻都在和bug作斗争。有时候会熬夜到两三点，倒不是因为ddl，更多的是心系bug。大约奋战了十多天吧，终于把较为完整的初版本完成了。嗯……UI还不错？漂流瓶还挺好玩？</p><p>六月的话，本来是要完成共享单车管理系统期末大作业的，但是刚开始没多久老师就决定拖延到暑假之后再交。既然老师都这么说了，那身为重度拖延症患者的我哪里还有做的道理<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><p><img src="http://ray34.cn-sh2.ufileos.com/博文/许久许久没有更博了./image-20200627112931584.png" alt="共享单车后台数据页面"></p><p>最近几天感觉挺颓的，老师遗留的一些课还没有看，前段时间买了好多书到现在一页都没翻过。人呐，一个月总有那么几十天是颓废的，过了就好啦<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f642.png?v8">🙂</span></p><p>写了那么多，一个是完成更博任务；一个也是记一记进来的近况，好让自己后来翻起来也有个念想。暑假快到了，希望你能继续保持积极快乐的心态，希望我也是！</p><p>如果快乐太难 那祝我早日更博<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f64d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f64d.png?v8">🙍</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流水账 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ucloud----对象存储的最终选择</title>
      <link href="/posts/64617.html"/>
      <url>/posts/64617.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>域名申请之后的第三个星期，阿里云终于通过了我的域名审核。鉴于此前dmca服务器架设在国外，本地阅览我博客里面的音乐视频效果都不是太好。加上picgo图床存放下的图片集杂乱无章，不好整理归档。因此我想寻找一个真正能够存放托管我博客大小文件的空间。此篇记录了我解决此问题的简要经历。</p><h3 id="picgo"><a href="#picgo" class="headerlink" title="picgo"></a>picgo</h3><p>博客中的文件，其实就是以图片视频音频这三类为主。在最开始的时候，为了简化操作，我将所有的文件都放在了项目根目录下，简单快捷，但对于网站的访问速度来说却是一大灾难。因此在后期优化的过程中，我开始寻找能够生成外链的公共空间。picgo+github存储是网上比较潮流的生成图片外链的方法。的确，在github平台的托管下，你可以在保证不掏腰包的状态下还能拥有无限的下载流量和无限的存储空间。而且上传下载速度也不用担心，因为在手动融合jsdelivr技术于此图床之后，就等同于拥有一个免费的cdn给你的博客加速，简直不能再好了。</p><blockquote><p>picgo样例：<a href="https://cdn.jsdelivr.net/gh/trayfour34/blog-photo-space/Blog_IMG/20200206020357.png" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/trayfour34/blog-photo-space/Blog_IMG/20200206020357.png</a></p></blockquote><h3 id="dmca"><a href="#dmca" class="headerlink" title="dmca"></a>dmca</h3><p>事实上，上面这个方法确实十分完美的解决了我80%的问题。可是picgo图床终归只是图床，github上也只能存放着我类似于png、bmp、jpg等图片类型，音乐和视频这些比较大的文件却无法存放于此。因此我想，只要再找个空间能够存放音频也就解决了。一顿知乎之后，发现dmca.gripe免费又简单，测试中流量速度也不慢。行，就它了！</p><p>理论上这个问题到此为止就算完美解决了。但后来同学测试完反映情况后我才知道，原来关了vpn之后加载速度堪忧，进度条半天才向前滑一点点。因此我只能另寻出路。</p><h3 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h3><p>之前，无论是图床还是音频空间，我主要是寻求一些比较次的免费产品，能省即省嘛<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8">😅</span>在dmca之后，我也尝试了<a href="https://coka.la/" target="_blank" rel="noopener">Coka.la</a>、<a href="https://streamable.com/" target="_blank" rel="noopener">Streamable</a>等，效果都不是太好。所以我转向寻求大产，寄希望于能碰上某个大产推出免费产品活动的契机（可惜没有）。腾讯云两年前还是可以白嫖的，现在似乎都没了，只推出免费六个月活动。阿里云和华为云需要长期收费。正当山重水复的时候，七牛云映入眼前，一个域名可享每日10G流量+10G存储空间+cdn加速，关键是免费啊。于是把东西都搬了过去，最后测试速度也没问题。大功告成！</p><blockquote><p>七牛云样例：<a href="http://q5okos5qx.bkt.clouddn.com/%E6%B8%A9%E6%9F%94.mp3" target="_blank" rel="noopener">温柔.mp3</a></p></blockquote><h3 id="备案风波"><a href="#备案风波" class="headerlink" title="备案风波"></a>备案风波</h3><p>但是几天之后我才发现，我忽略了一行小小的tip，如下</p><p><img src="http://ray34.cn-sh2.ufileos.com/%E5%8D%9A%E6%96%87%2FUcloud----%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9%2F1.png" alt="tip" style="zoom: 67%;"></p><p>也就是说，它给我的是一个测试域名，测试域名要回收，需要创建自定义域名才能永久使用。然而创建自定义域名要将域名备案……</p><p><img src="http://ray34.cn-sh2.ufileos.com/%E5%8D%9A%E6%96%87%2FUcloud----%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9%2F2.png" alt="备案域名才能使用" style="zoom: 67%;"></p><p>行，备案就备案吧，再等个几天也不是什么事儿。</p><p>然而，当我把填写备案信息的时候我才发现，原来备案要买备案商的服务器或者虚拟主机，阿里云最便宜的也要一百多块一年….额溜了溜了。</p><p><img src="http://ray34.cn-sh2.ufileos.com/%E5%8D%9A%E6%96%87%2FUcloud----%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9%2F3.png" alt="备案" style="zoom: 50%;"></p><p>那个时候还想看看能不能白嫖到一台云主机来备案，所以从阿里云的<strong>万网虚机试用</strong>服务和aws的一年免费主机，但都显示只有转正了才能备案。这条路也断了…</p><h3 id="Ucloud"><a href="#Ucloud" class="headerlink" title="Ucloud"></a>Ucloud</h3><p>最后在漫无目的的搜寻之中，我发现了青云和Ucloud两个不太出名的云服务商。Ucloud推出每个月20G的流量+20G的存储空间，完全适用于小博客的运维。而且Ucloud的客服真的是圈粉了，提交的工单总是能在很短的时间内就予以回复。在开通之前还给我通了个电话，确认我开通对象存储的要求，并嘱咐我注意流量的使用，因为流量超出是没有短信提醒的。（亲身经历，不是打广告<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>）</p><p><img src="http://ray34.cn-sh2.ufileos.com/%E5%8D%9A%E6%96%87%2FUcloud----%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9%2F4.png" alt="(工单)"></p><blockquote><p>Ucloud样例：<a href="http://ray34.cn-sh2.ufileos.com/home%2F%E6%B8%A9%E6%9F%94.png" target="_blank" rel="noopener">http://ray34.cn-sh2.ufileos.com/home%2F%E6%B8%A9%E6%9F%94.png</a></p></blockquote><p>而且它提供一个域名多个地区服务，每个地区20G流量+20G空间。结算下来一百多G，已经是很大很大了。如果能自己实现负载均衡的话，后台就可以自己判断哪个地区的空间多，然后自动把文件放在哪里。具体的实现可以看看这篇文章   <a href="https://www.xiebruce.top/644.html" target="_blank" rel="noopener">使用nginx负载均衡+多个云的免费额度打造免费markdown图床</a>    </p><p>另外，相比之下Ucloud还有一点做的很好，就是文件归档。对比七牛或者阿里云亦或是picgo图床，Ucloud可以像在本地新建文件夹命名文件夹一样，把图片视频以文件夹的形式分好。对比如下：</p><p><img src="http://ray34.cn-sh2.ufileos.com/%E5%8D%9A%E6%96%87%2FUcloud----%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9%2F5.png" alt="(七牛云)"></p><p><img src="http://ray34.cn-sh2.ufileos.com/%E5%8D%9A%E6%96%87%2FUcloud----%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9%2F6.png" alt="(picgo)"></p><p><img src="http://ray34.cn-sh2.ufileos.com/%E5%8D%9A%E6%96%87%2FUcloud----%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9%2F7.png" alt="(Ucloud)"></p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>至此，这个问题终究告一段落，不会再有反转了哈哈。在这个过程中我也懂了不少东西，也并非完全浪费时间<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8">😏</span>其中还发现了阿里云的虚机试用，后续可以借此机会好好看看。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 发现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ucloud </tag>
            
            <tag> picgo </tag>
            
            <tag> 七牛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dmca.gripe:永久托管你的小文件</title>
      <link href="/posts/20976.html"/>
      <url>/posts/20976.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>此篇是我严格意义上的第一篇博文。选择这个主题也是因为在后续优化博客的过程中碰到了相应的问题。故借此机会写下来分享分享。</p><p>因为自己想要在博客中增添音乐和视频板块，在搭建博客的时候参考别人的博客，发现大部分人都是去通过找寻免费的音频网站，获取外链的方式将音乐地址。但这样找寻地址既麻烦，又不能保证音频地址的长期有效性。因为大多数免费音频网站的音乐地址并不是永久固定的，一旦某日链接失效就不能用了。</p><p>我在搭建的时候，为了图方便，把视频和音乐事先下载好放在根目录下，然后将所有音乐和视频的url全部设置成本地地址。但在后期优化的过程中，我发现这样子做虽然确保了链接的永久有效性，但却大大影响了访问速率（一个视频的大小就相当于我其他文件的总和了）。因此，我想找一个既简单免费（毕竟为了这个需求去阿里云买空间实在不值得）、又能永久托管储存我的一些小文件的工具。而 dmca.gripe 完美符合我的需求。</p><p>dmca.gripe下，每个文件的最大上传大小是 5120MB，有账户机制，创建一个账户后便有一个属于你自己的云空间。经测试，上传下载速度都不成问题。任何文件都可以上传。因为博客中的图片，音乐，视频都需要外链，所以我以以上三种文件类型进行测试。</p><p><a href="https://dmca.gripe/" target="_blank" rel="noopener">点击进入dema.gripe</a></p><hr><h3 id="图片外链测试"><a href="#图片外链测试" class="headerlink" title="图片外链测试"></a>图片外链测试</h3><p><img src="https://share.dmca.gripe/yz94A9s1yL956wBr.jpg" alt="img"></p><pre><code>https://share.dmca.gripe/yz94A9s1yL956wBr.jpg</code></pre><h3 id="视频外链测试"><a href="#视频外链测试" class="headerlink" title="视频外链测试"></a>视频外链测试</h3><p><video playsinline="" webkit-playsinline="" preload="auto" controls="" src="https://share.dmca.gripe/o0svzfA3yJtXnrMI.mp4" width="100%">视频由ray分享，如果您看到这段话说明视频已经失效.</video></p><pre><code>https://share.dmca.gripe/o0svzfA3yJtXnrMI.mp4</code></pre><h3 id="音乐外链测试"><a href="#音乐外链测试" class="headerlink" title="音乐外链测试"></a>音乐外链测试</h3><audio controls="controls">  <source src="https://share.dmca.gripe/pGyp6q8ii3EDZ4ZI.mp3" type="audio/ogg"><embed height="100" width="100" src="/i/song.mp3"></audio><pre><code>https://share.dmca.gripe/pGyp6q8ii3EDZ4ZI.mp3</code></pre><h3 id="文件下载测试"><a href="#文件下载测试" class="headerlink" title="文件下载测试"></a>文件下载测试</h3><h5 id="花海-mp3"><a href="#花海-mp3" class="headerlink" title="花海.mp3"></a><a href="https://share.dmca.gripe/pGyp6q8ii3EDZ4ZI.mp3" target="_blank" rel="noopener">花海.mp3</a></h5><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><hr><h5 id="2月22日更新："><a href="#2月22日更新：" class="headerlink" title="2月22日更新："></a>2月22日更新：</h5><h6 id="由于该网站的服务器架设在国外，所以没有挂vpn的话速度会有点慢。（之前测试一直是挂着vpn-smile-）"><a href="#由于该网站的服务器架设在国外，所以没有挂vpn的话速度会有点慢。（之前测试一直是挂着vpn-smile-）" class="headerlink" title="由于该网站的服务器架设在国外，所以没有挂vpn的话速度会有点慢。（之前测试一直是挂着vpn:smile:）"></a>由于该网站的服务器架设在国外，所以没有挂vpn的话速度会有点慢。（之前测试一直是挂着vpn<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>）</h6><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 发现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gripe </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is my very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start-smile-smile-smile-smile"><a href="#Quick-Start-smile-smile-smile-smile" class="headerlink" title="Quick Start :smile: :smile::smile: :smile:"></a>Quick Start :smile: :smile::smile: :smile:</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"<div class="statis">    <span class="count"><a href="<%- url_for('/categories') %>" target="_blank"><%- site.categories.length %></a></span>    <span class="name"><%- __('categories') %></span></div><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
